# v0.3.0: Schedule-Time Validation

**Status:** Planned  
**Target Version:** 0.3.0  
**Estimated Effort:** 1-2 days  
**Date:** 2026-02-05

## Overview

Add optional parameter validation at **schedule creation time** instead of only at execution time. This catches configuration errors early and provides immediate feedback to users.

### Current Behavior (v0.2.0)
- Parameters validated only when job executes
- `KeyError`, `TypeError`, `ValueError` happen at execution time
- Errors logged to JobExecutionLog after job already scheduled

### New Behavior (v0.3.0)
- **Optional** validators run at schedule creation time
- Invalid parameters rejected with HTTP 400 before schedule is created
- Backward compatible: handlers without validators work unchanged

---

## Feature Design

### Three Validation Paths

#### Path 1: Pydantic Models (Automatic Validation)

Handlers using Pydantic get validation for free:

```python
from pydantic import BaseModel, Field

class MyTaskParams(BaseModel):
    user_id: int = Field(..., gt=0)
    limit: int = Field(100, le=1000)
    email: str = Field(..., pattern=r'^[\w\.-]+@[\w\.-]+\.\w+$')

class MyHandler(AutonomousHandler):
    def my_task(self, params: dict):
        validated = MyTaskParams(**params)
        return process(validated.user_id)
    
    async def setup(self):
        # Pydantic model IS the validator
        self.register_handler(self.my_task, validator=MyTaskParams)
```

#### Path 2: Custom Validator Functions

For handlers not using Pydantic:

```python
def my_task(self, params: dict):
    return process(params["user_id"])

def validate_my_task(params: dict) -> dict:
    """Custom validation logic"""
    errors = {}
    if "user_id" not in params:
        errors["user_id"] = "Required parameter"
    if params.get("limit", 0) > 1000:
        errors["limit"] = "Cannot exceed 1000"
    
    return {"valid": len(errors) == 0, "errors": errors}

# Register with custom validator
self.register_handler(my_task, validator=validate_my_task)
```

#### Path 3: No Validator (Current Behavior)

```python
def my_task(self, params: dict):
    return process(params["user_id"])  # KeyError at execution if missing

# No validator - backward compatible
self.register_handler(my_task)
```

---

## Implementation

### Local Handlers (Autonomous)

**Files to Modify:**

1. **`local_handler_registry.py`** (~25 lines)
   ```python
   def register(self, handler_id: str, func: Callable, 
                methods: list[str] | None = None,
                validator: Callable | type | None = None) -> bool:
       # Store validator in handler_info
       self._handlers[handler_id] = {
           'function': func,
           'methods': methods,
           'validator': validator,  # NEW
           # ... existing fields
       }
   
   def get_validator(self, handler_id: str) -> Callable | type | None:
       """Get validator for a handler."""
       handler = self._handlers.get(handler_id)
       return handler.get('validator') if handler else None
   ```

2. **`autonomous_handler.py`** (~5 lines)
   ```python
   def register_handler(self, func: Callable, 
                       methods: list[str] | None = None,
                       validator: Callable | type | None = None) -> Callable:
       # Pass validator through to registry
       self.local_registry.register(self.handler_id, func, methods, validator)
       return func
   ```

3. **`api/job_scheduling_api.py`** (~40 lines)
   ```python
   # After line 46 (method validation)
   validator = handler_info.get("validator")
   if validator:
       try:
           validation_result = self._run_validator(validator, job_params)
           if not validation_result["valid"]:
               return self.send_error(400, 
                   reason=f"Parameter validation failed: {validation_result['errors']}")
       except Exception as e:
           logger.error(f"Validator error: {e}", exc_info=True)
           return self.send_error(500, 
               reason=f"Validator execution failed: {e}")
   
   def _run_validator(self, validator, params: dict) -> dict:
       """Run validator (Pydantic or custom function)."""
       # Check if Pydantic model
       if isinstance(validator, type):
           try:
               from pydantic import BaseModel, ValidationError
               if issubclass(validator, BaseModel):
                   validator(**params)  # Raises ValidationError
                   return {"valid": True, "errors": {}}
           except ValidationError as e:
               return {"valid": False, "errors": e.errors()}
       
       # Custom validator function
       result = validator(params)
       if not isinstance(result, dict) or "valid" not in result:
           raise ValueError("Validator must return {'valid': bool, 'errors': dict|list}")
       return result
   ```

### Remote Handlers (ZMQ)

**Validation Protocol:** Call `validate_<method_name>` on remote handler

**Files to Modify:**

1. **`zmq_handler_base.py`** (~30 lines)
   ```python
   def _handle_request(self, request: dict) -> dict:
       method_name = request.get("method")
       params = request.get("params", {})
       
       # Check for validation request
       if method_name.startswith("validate_"):
           actual_method = method_name.replace("validate_", "")
           validator_name = f"validate_{actual_method}"
           
           if hasattr(self, validator_name):
               # Call validator method
               validator = getattr(self, validator_name)
               sig = inspect.signature(validator)
               if len(sig.parameters) > 0:
                   result = validator(params)
               else:
                   result = validator()
               
               # Ensure proper format
               if not isinstance(result, dict) or "valid" not in result:
                   return {"valid": True, "errors": {}}
               return result
           
           # No validator = always valid
           return {"valid": True, "errors": {}}
       
       # Normal method execution (existing code)
       # ...
   ```

2. **`api/job_scheduling_api.py`** (add to existing validation section)
   ```python
   # For remote handlers
   if handler_info.get("type") == "remote":
       try:
           client = registry_manager.get_client(handler_id)
           if client:
               # Try calling validate_<method> on remote handler
               validation_result = client.call(f"validate_{job_method}", job_params)
               
               if not validation_result.get("valid", True):
                   return self.send_error(400,
                       reason=f"Validation failed: {validation_result.get('errors')}")
       except Exception as e:
           # Validation method doesn't exist or handler offline
           # Continue without validation (backward compatible)
           logger.debug(f"Remote validation not available: {e}")
   ```

---

## Testing

### Unit Tests

**New file:** `tests/test_schedule_time_validation.py`

```python
@pytest.mark.asyncio
async def test_pydantic_validation_success():
    """Test Pydantic model accepts valid params"""
    # Create handler with Pydantic validator
    # Schedule job with valid params
    # Assert: Schedule created

@pytest.mark.asyncio
async def test_pydantic_validation_failure():
    """Test Pydantic model rejects invalid params"""
    # Create handler with Pydantic validator
    # Schedule job with missing required field
    # Assert: HTTP 400 error

@pytest.mark.asyncio
async def test_custom_validator_success():
    """Test custom validator function accepts valid params"""
    # ...

@pytest.mark.asyncio
async def test_custom_validator_failure():
    """Test custom validator function rejects invalid params"""
    # ...

@pytest.mark.asyncio
async def test_no_validator_backward_compatible():
    """Test handlers without validators still work"""
    # ...

@pytest.mark.asyncio
async def test_remote_handler_validation():
    """Test remote handler validation via RPC"""
    # Mock ZMQ handler with validate_method
    # Schedule job
    # Verify validation RPC was called
```

### Integration Tests

Add validation to existing test handlers:
- `tests/test_handler.py` - Add `validate_do_work()` method
- Verify end-to-end flow with validation

---

## API Changes

### Schedule Job Endpoint

**Existing:** `POST /api/schedule`

**New Behavior:**
- If handler has validator → validate params before scheduling
- Return HTTP 400 with detailed errors if validation fails
- Otherwise unchanged (backward compatible)

**Error Response Format:**

```json
{
  "status": "error",
  "reason": "Parameter validation failed: {'user_id': 'Required parameter', 'limit': 'Cannot exceed 1000'}"
}
```

---

## Migration Guide

### For Handler Developers

**No changes required** - all handlers continue to work unchanged.

**To add validation:**

1. **With Pydantic:**
   ```python
   # Add pydantic model
   from pydantic import BaseModel
   
   class MyParams(BaseModel):
       user_id: int
       limit: int = 100
   
   # Register with validator
   self.register_handler(my_task, validator=MyParams)
   ```

2. **With custom function:**
   ```python
   def validate_my_task(params: dict) -> dict:
       errors = {}
       if "required_field" not in params:
           errors["required_field"] = "Required"
       return {"valid": len(errors) == 0, "errors": errors}
   
   self.register_handler(my_task, validator=validate_my_task)
   ```

3. **For remote handlers:**
   ```python
   class MyHandler(ZMQHandlerBase):
       def my_task(self, params):
           return process(params["data"])
       
       def validate_my_task(self, params):
           """Validator called via RPC at schedule time"""
           if "data" not in params:
               return {"valid": False, "errors": {"data": "Required"}}
           return {"valid": True, "errors": {}}
   ```

---

## Benefits

1. **Early Error Detection** - Catch config errors before scheduling
2. **Better UX** - Immediate feedback to API users
3. **Type Safety** - Pydantic integration for type checking
4. **Backward Compatible** - Opt-in feature, no breaking changes
5. **Unified Protocol** - Same approach for local and remote handlers
6. **Reduced Execution Failures** - Fewer jobs fail due to bad parameters

---

## Considerations

### Pydantic Dependency

**Decision:** Make Pydantic **optional**
- Don't add to required dependencies
- Check `try: from pydantic import BaseModel` in validator code
- If Pydantic not installed, treat model class as regular validator

### Remote Handler Availability

**Issue:** Validation requires remote handler to be online at schedule time

**Solution:** Make validation optional
- If handler offline or validation method missing → skip validation
- Log warning but allow schedule creation
- Execution-time validation still happens (current behavior as fallback)

### Performance

**Impact:** Minimal
- Local handlers: Function call overhead (~1ms)
- Remote handlers: One extra RPC call (~10-50ms)
- Only affects schedule creation (not execution)

---

## Documentation Updates

### Files to Update

1. **`README.md`** - Add validation feature to features list
2. **`docs/handlers/validation.md`** - New page explaining validation
3. **`docs/api/schedule-job.md`** - Document validation errors
4. **`examples/handler_with_validation.py`** - Example handler

---

## Timeline

**Phase 1 (Day 1):** Local handler validation
- Modify `local_handler_registry.py`
- Modify `autonomous_handler.py`
- Add validation to `job_scheduling_api.py`
- Write unit tests

**Phase 2 (Day 2):** Remote handler validation
- Modify `zmq_handler_base.py`
- Add remote validation to `job_scheduling_api.py`
- Write integration tests
- Documentation

**Total:** 1-2 days for complete implementation

---

## Future Enhancements

- **Schema introspection:** API endpoint to get parameter schema from Pydantic models
- **OpenAPI generation:** Auto-generate API docs from Pydantic validators
- **Validation caching:** Cache validation results for repeated schedules
- **Async validators:** Support async validation functions for database lookups
